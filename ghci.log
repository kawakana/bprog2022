GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-05-19 15:41:27.6007665
>>> 12 + 12
24
2022-05-19 15:54:29.0325321
>>> 3 + 3 * 3
12
2022-05-19 15:55:13.9892169
>>> 10 - 5
5
2022-05-19 15:55:44.1251124
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:45.3777276
>>> double 3

<interactive>:5:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:36.3574381
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-05-26 15:02:11.1368592
>>> maxBound :: Int
9223372036854775807
2022-05-26 15:03:46.1833799
>>> 2 ^ 63 - 1
9223372036854775807
2022-05-26 15:05:04.3585976
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:37.4911008
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, no modules loaded.
2022-05-26 15:49:04.6585086
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:49:04.6976001
>>> double 3
6
2022-05-26 15:56:27.2545128
>>> double (1 + 3)
8
2022-05-26 15:57:07.5985262
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-06-09 14:55:11.3281123
>>> 2 + 3 * 4
14
2022-06-09 14:57:45.6838385
>>> (2 + 3) * 4
20
2022-06-09 15:00:14.2751592
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:00:51.2433925
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:05:16.4252154
>>> sqrt (25 :: Int)

<interactive>:5:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:18.130697
>>> sqrt (25 :: Double)
5.0
2022-06-09 15:09:25.5733071
>>> sqrt 25
5.0
2022-06-09 15:10:14.323501
>>> hoge 25 :: Int

<interactive>:8:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:14:02.4651384
>>> head [1, 2, ]3

<interactive>:9:13: error: parse error on input ‘]’
2022-06-09 15:46:39.3616329
>>> head [1, 2, 3]
1
2022-06-09 15:47:19.7710834
>>> head [3, 1, 4, 1, 5]
3
2022-06-09 15:47:50.8178274
>>> head []
*** Exception: Prelude.head: empty list
2022-06-09 15:49:39.6134905
>>> hoge = [3, 1, 4, 1, 5] :: [Int]
2022-06-09 15:50:39.5965105
>>> hoge
[3,1,4,1,5]
2022-06-09 15:50:56.2632412
>>> head hoge
3
2022-06-09 15:51:26.1829825
>>> tail hoge
[1,4,1,5]
2022-06-09 15:51:47.6824765
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:34.6334579
>>> hoge !! 0
3
2022-06-09 15:55:08.0974355
>>> hoge 2 !!

<interactive>:19:10: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 15:55:17.8053259
>>> hoge 2 !! hoge

<interactive>:20:1: error:
    • Couldn't match expected type: t0 -> [a]
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the first argument of ‘(!!)’, namely ‘hoge 2’
      In the expression: hoge 2 !! hoge
    • Relevant bindings include it :: a (bound at <interactive>:20:1)

<interactive>:20:11: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Int]’
    • In the second argument of ‘(!!)’, namely ‘hoge’
      In the expression: hoge 2 !! hoge
      In an equation for ‘it’: it = hoge 2 !! hoge
2022-06-09 15:55:50.301254
>>> hoge !! 2
4
2022-06-09 15:56:23.9187403
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:56.1187203
>>> hoge
[3,1,4,1,5]
2022-06-09 15:57:02.05112
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:24.6415805
>>> hoge 5 hoge

<interactive>:25:1: error:
    • Couldn't match expected type: t0 -> [Int] -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to two value arguments,
        but its type ‘[Int]’ has none
      In the expression: hoge 5 hoge
      In an equation for ‘it’: it = hoge 5 hoge
    • Relevant bindings include it :: t (bound at <interactive>:25:1)
2022-06-09 15:58:25.8748779
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:59:02.5434579
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:24.2852163
>>> drop 10 hoge
[]
2022-06-09 16:00:31.1747048
>>> length hoge
5
2022-06-09 16:01:10.7366881
>>> length []
0
2022-06-09 16:01:25.3763471
>>> sum hoge
14
2022-06-09 16:02:04.1351227
>>> product hoge
60
2022-06-09 16:03:05.397948
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:56.068315
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:43.9034984
>>> : load src/First.hs

<interactive>:1:1: error: Not in scope: ‘load’
2022-06-09 16:07:54.9346354
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, no modules loaded.
2022-06-09 16:08:57.9147043
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:08:57.9545302
>>> double 3 + 3
9
2022-06-09 16:10:21.5115572
>>> double (3 + 3)
12
2022-06-09 16:11:31.1261993
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  quadruple :: Int -> Int
   6  quadruple x = double (double x)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:14:38.8388016
>>> quadruple 2
8
2022-06-09 16:15:00.2624828
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-06-16 15:02:05.7686262
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:23.1806909
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:10:49.7838185
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:10:49.823746
>>> double

<interactive>:4:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:12:56.3044829
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:19.6138379
>>> [1 ..10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:42.2897737
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:21:05.0723271
>>> factorial 3
6
2022-06-16 15:22:35.6531735
>>> factorial 4
24
2022-06-16 15:25:01.9224215
>>> :r]
unknown command ':r]'
use :? for help.
2022-06-16 15:38:25.7989296
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs 'div' length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:21: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
   |
13 | average xs = sum xs 'div' length xs
   |                     ^^^^^
Failed, no modules loaded.
2022-06-16 15:38:50.7097228
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div`` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:26: error: parse error on input ‘`’
   |
13 | average xs = sum xs `div`` length xs
   |                          ^
Failed, no modules loaded.
2022-06-16 15:39:35.6588949
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:39:46.5402873
>>> average [1,2,3,4,5]
3
2022-06-16 15:40:24.9456401
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:49:53.9786574
>>> 
2022-06-16 16:06:24.0972911
>>>  init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:17.6699319
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:28.8385264
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:14:55.3041717
>>> myinit []
*** Exception: src/First.hs:(19,1)-(20,29): Non-exhaustive patterns in function myinit

2022-06-16 16:15:09.9385205
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-06-23 14:54:55.876279
>>> :i
syntax: ':i <thing-you-want-info-about>'
2022-06-23 14:55:50.1349849
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:41.7693637
>>> 
2022-06-23 15:00:59.9366279
>>> 
2022-06-23 15:01:29.2290126
>>> 1==2
False
2022-06-23 15:06:16.1577575
>>> 1 < 2
True
2022-06-23 15:06:26.117171
>>> 1 < 1
False
2022-06-23 15:06:34.857573
>>> 1 <= 2
True
2022-06-23 15:06:51.191048
>>> 1 >= 2
False
2022-06-23 15:07:12.2947675
>>> 'a' < 'b'
True
2022-06-23 15:11:29.5458187
>>> 'a' < 'B'
False
2022-06-23 15:11:49.6878077
>>> '' < 'a'

<interactive>:12:1: error:
    Parser error on `''`
    Character literals may not be empty
2022-06-23 15:12:27.7890766
>>> 'ab' < 'b'

<interactive>:13:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:12:58.434537
>>> 1 /= 2
True
2022-06-23 15:15:57.2947928
>>> 1 /= 1
False
2022-06-23 15:16:14.4588871
>>> :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:16.8440385
>>> abs

<interactive>:17:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:49.9556637
>>> abs (-234)
234
2022-06-23 15:34:38.6735603
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-06-30 14:56:41.3886903
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-06-30 15:02:29.5549143
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:05:06.0674189
>>> [ x * 2 | x <- [1..5] ]
[2,4,6,8,10]
2022-06-30 15:12:52.8322523
>>> [ x 'div' 2 | x <- [1 .. 5] ]

<interactive>:4:5: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-06-30 15:13:54.4961072
>>> [ x `div` 2 | x <- [1 .. 5] ]
[0,1,1,2,2]
2022-06-30 15:14:29.6349217
>>> [ x `divMod` 2 | x <- [1 .. 5] ]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-06-30 15:15:33.9361598
>>> [ (x,y) | x <- "abc", y <- [4.5] ]
[('a',4.5),('b',4.5),('c',4.5)]
2022-06-30 15:20:56.7810376
>>> [ (x,y) | y <- [4, 5], x <- "abc"] ]

<interactive>:8:36: error: parse error on input ‘]’
2022-06-30 15:22:55.1839033
>>> [ (x,y) | y <- [4, 5], x <- "abc"]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:23:06.1280376
>>> 
2022-06-30 15:23:56.0118623
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat css = [ x | xs <- xss, x <- xs ]
Ok, no modules loaded.
2022-06-30 15:30:06.505827
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:23:28: error:
    • Variable not in scope: xss :: [[a]]
    • Perhaps you meant ‘css’ (line 23)
   |
23 | myconcat css = [ x | xs <- xss, x <- xs ]
   |                            ^^^
Failed, no modules loaded.
2022-06-30 15:30:06.5412759
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:32:43.263832
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:32:43.3580254
>>> [ 1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:47:51.3727436
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs ]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:50:39.4414387
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:50:39.539943
>>> mylength ['a' .. 'z']
26
2022-06-30 15:51:26.9628005
>>> ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:52:24.2522032
>>> putStrLn it
abcdefghijklmnopqrstuvwxyz
2022-06-30 15:52:59.2826491
>>> ['あ'.. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:54:04.3651598
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:55:11.1758694
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-07-07 16:05:03.556199
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, no modules loaded.
2022-07-07 16:05:36.2829576
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:05:36.3281811
>>> ord `A`

<interactive>:3:8: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-07 16:05:53.0211777
>>> ord 'A'
65
2022-07-07 16:06:51.8611679
>>> ord 'a'
97
2022-07-07 16:07:13.9331811
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kana/bprog2022/.ghci
2022-07-14 15:11:16.023414
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c
Ok, no modules loaded.
2022-07-14 15:11:46.4990744
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:11:46.5838777
>>> let2int 

<interactive>:3:1: error:
    • No instance for (Show (Char -> Int))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-14 15:12:27.5426858
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:13:12.807717
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:13:12.9043349
>>> let2int `a`

<interactive>:6:12: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-14 15:13:35.0346832
>>> let2int 'a'
97
2022-07-14 15:13:54.0821606
>>> let2int 'z'
122
2022-07-14 15:14:10.5714278
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:11.9328526
>>> let2int 'a'
0
2022-07-14 15:15:37.5741205
>>> let2int 'z'
25
2022-07-14 15:15:49.8309003
>>> ord 'a'
97
2022-07-14 15:19:29.0731068
>>> chr 97
'a'
2022-07-14 15:19:41.034471
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:20:15.323866
>>> int2let 0
'a'
2022-07-14 15:20:29.1204336
>>> int2let 25
'z'
2022-07-14 15:20:37.5428945
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c ; c) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:39: error: parse error on input ‘;’
   |
13 |     | isLower c = int2let ((let2int c ; c) `mod` 26)
   |                                       ^
Failed, no modules loaded.
2022-07-14 15:28:54.9875634
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:29:22.9985504
>>> shift 3 'a'
'd'
2022-07-14 15:29:45.0859929
>>> shift (-3) 'd'
'a'
2022-07-14 15:30:05.6204746
>>> shift 3 'z'
'c'
2022-07-14 15:30:22.7174327
>>> shift 3 ' '
' '
2022-07-14 15:32:55.3607077
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:36:01.1393176
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:37:05.2274911
>>> encode 3 "hashell is fun"
"kdvkhoo lv ixq"
2022-07-14 15:48:10.2618793
>>> it
"kdvkhoo lv ixq"
2022-07-14 15:48:23.3532987
>>> encode (-3) it
"hashell is fun"
2022-07-14 15:48:58.5930325
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:20:10: error:
    • No instance for (Fractional float) arising from the literal ‘8.1’
      Possible fix:
        add (Fractional float) to the context of
          the type signature for:
            table :: forall float. [float]
    • In the expression: 8.1
      In the expression: [8.1, 1.5, 2.8, 4.2, ....]
      In an equation for ‘table’: table = [8.1, 1.5, 2.8, ....]
   |
20 | table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
   |          ^^^
Failed, no modules loaded.
2022-07-14 15:59:16.4029405
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:20:11: error:
    • No instance for (Fractional float) arising from the literal ‘8.1’
      Possible fix:
        add (Fractional float) to the context of
          the type signature for:
            table :: forall float. [float]
    • In the expression: 8.1
      In the expression: [8.1, 1.5, 2.8, 4.2, ....]
      In an equation for ‘table’: table = [8.1, 1.5, 2.8, ....]
   |
20 | table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
   |           ^^^
Failed, no modules loaded.
2022-07-14 15:59:31.495099
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:00:41.802033
>>> length table
26
2022-07-14 16:01:07.8177703
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = n / m * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n / m * 100
   |               ^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 16:06:55.8881585
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (flomIntegral n / flomIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:16: error:
    • Variable not in scope: flomIntegral :: Int -> Float
    • Perhaps you meant ‘fromIntegral’ (imported from Prelude)
   |
26 | percent n m = (flomIntegral n / flomIntegral m) * 100
   |                ^^^^^^^^^^^^

src/Caesar.hs:26:33: error:
    • Variable not in scope: flomIntegral :: Int -> Float
    • Perhaps you meant ‘fromIntegral’ (imported from Prelude)
   |
26 | percent n m = (flomIntegral n / flomIntegral m) * 100
   |                                 ^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 16:09:25.2915292
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (flomIntegral n / fromIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:16: error:
    • Variable not in scope: flomIntegral :: Int -> Float
    • Perhaps you meant ‘fromIntegral’ (imported from Prelude)
   |
26 | percent n m = (flomIntegral n / fromIntegral m) * 100
   |                ^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 16:09:50.1001196
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:10:01.7580723
>>> percent 5 15
33.333336
2022-07-14 16:10:16.9898073
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Chart -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:28:10: error:
    Not in scope: type constructor or class ‘Chart’
    Perhaps you meant ‘Char’ (imported from Data.Char)
   |
28 | count :: Chart -> (String -> Int)
   |          ^^^^^
Failed, no modules loaded.
2022-07-14 16:14:24.7240466
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0 
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23           ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:14:37.0849579
>>> percent 5 15
33.333336
2022-07-14 16:14:57.2080478
>>> count 's' "Mississippi"
4
2022-07-14 16:15:43.4105092
>>> :q
Leaving GHCi.
